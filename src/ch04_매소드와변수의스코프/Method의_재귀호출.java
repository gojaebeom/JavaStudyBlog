package ch04_매소드와변수의스코프;

public class Method의_재귀호출 {
	
	/**
	 * @재귀호출
	 * 자바는 메소드의 '재귀적 호출'을 지원한다.
	 * 따라서 이에 대해 설명할 텐데, 메소드의 재귀적 호출은 자료구조와 알고리즘의 구현에 유용한 문법이므로
	 * 조금 내용이 어렵다.
	 * 
	 * 
	 * @수학적 측면에서의 재귀적인 사고
	 * 고등학교 수학에서 접하는 팩토리얼(Factorial)은 기호 !으로 표현하며 계산 방식은 다음과 같다.
	 * 5! = 5 x 4 x 3 x 2 x 1
	 * 4! = 4 x 3 x 2 x 1
	 * 3! = 3 x 2 x 1
	 * 2! = 2 x 1
	 * 1! = 1
	 * 
	 * 때문에 위의 팩토리얼의 계산식은 다음과 같이 쓸 수 있다.
	 * 5! = 5 x 4!
	 * 4! = 4 x 3!
	 * 3! = 3 x 2!
	 * 2! = 2 x 1!
	 * 1! = 1
	 * (뭐하는 건지 모르겟다;; 수학공부좀 열심히할껄..)
	 * 
	 * 위의 식에서 재귀(순환)를 발견할 수 있다. 팩토리얼의 계산식에 다시 팩토리얼이 등장한 이 상황이 바로 '재귀'이기 때문이다.
	 * 
	 * 
	 */
	
	public static void main(String[] args) {
		System.out.println("3 factorial : " + factorial(3));

	}
	
	public static int factorial(int n) {
		
		if(n == 1) //if문 다음으로 오는 내용이 한줄만있다면 {중괄호}를 생략 가능하다.
			return 1;
		
		return n * factorial(n-1);
		/**
		 * 내용이 어려울 수도있지만, 차근차근 정리해보자면
		 * 
		 * -메소드 main에서 메소드 factorial를 호출하면서 3이라는 인자값을 전달한다.
		 * -if조건문이 참이 아니기에 무시하고 3 * factorial(n-1)을 반환한다.
		 *  	즉 3* (3-1=2) 이기때문에 3*2를 반환한다 라고 할 수 있다.
		 * 
		 * 하지만 여기서 끝난게 아니다. 반환하기 이전 메소드factorial(n-1)은 자기 자신을 다시 호출하게 된다.
		 * 
		 * 그러면 다시 메소드factorial에게 인자값 2를 전달한다.
		 * - if조건이 참이 아니기에 무시하고 2 * 1을 반환한다. 
		 * 
		 * 그리고 다시 함수에 1이라는 매개변수를 넘기고
		 * 이번엔 n이 1이라는 조건을 만족하기 때문에 1을 반환하면서 자신을 마지막으로 호출한 
		 * return 2 * factorial(1)에 1이라는 값을 던져준다.
		 * 
		 * 아 뭐라는지 모르겠다. 뇌가 생각하기를 거부하는거같은데 예제풀이를 해보면서 다시 이해해보기로 한다.
		 *
		 */
	}

}
